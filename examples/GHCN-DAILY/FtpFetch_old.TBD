import { ctrl, Action, action } from "../../cxctrl/mod.ts"
import * as path from "https://deno.land/std@0.74.0/path/mod.ts"
import FTPClient from "https://deno.land/x/ftpc@v1.1.0/mod.ts"
import { actionFactory } from "../../cxctrl/mod.ts"
import { CxError } from "../../cxutil/mod.ts"
import { sprintf } from "https://deno.land/std/fmt/printf.ts"
import { config } from "./config.ts"

const __filename = new URL('', import.meta.url).pathname;


export type FtpFetchObjectType = {
    ftpServer:  string,
    ftpPath:    string,
    fileName:   string,
    fileInfo?:  Deno.FileInfo,
    data?:      Uint8Array,
    status?:    boolean
    info?:      string
}

@action({
    state: [] as FtpFetchObjectType[]
})
export class FtpList extends Action<FtpFetchObjectType[]> {
    constructor( public server: string = config.ftpConf.server, public directory: string = config.ftpConf.directory ) {
        super()
    }
    async main (): Promise<boolean> {
        let self = this
        try {
            // console.log ( `running ${this.meta.name}`)
            let ftpClient = new FTPClient(this.server) 
            await ftpClient.connect()
            await ftpClient.chdir(this.directory)
            let fileList = (await ftpClient.list()).sort()

            fileList.forEach( async (fileName, idx ) => {
                self.state[idx] = {
                    ftpServer: self.server,
                    ftpPath:  self.directory,
                    fileName: fileName
                }
            })
            ftpClient.close()
            this.publish()
        }
        catch( err) {
            throw new CxError( __filename, 'FtpList', 'FTP-0001',`ftpList.main() failed with: ${err}`, err)
        }
        return Promise.resolve(true)
    }
}

@action({
    state:   {
        fileObj: {}
    },
    init: false
})

export class FtpFetch extends Action<FtpFetchObjectType> {

    constructor( state: FtpFetchObjectType) {
        super(state)
    }
    
    async main() {    
        try {
            let ftpClient = new FTPClient(config.ftpConf.server)  //"ftp.ncdc.noaa.gov"
            await ftpClient.connect()
            let dir = path.dirname(this.state.ftpPath)
            await ftpClient.chdir( dir) 
            let fileName = path.basename(this.state.ftpPath)
            this.state.fileInfo = await ftpClient.stat(this.state.fileName)
            // this.state.data = await ftpClient.download(fileName)
            this.state.status = true
            ftpClient.close()
            this.publish()
        }
        catch( err) {
            throw new CxError( __filename, 'ftpFetch.getState()', 'FTP-0002',`SwarmReader.main() failed with: ${err}`, err)
        }

        return Promise.resolve(true)
    }
}

@action({
    state: new Map<string, FtpFetchObjectType[]>(),
})
export class SwarmFtp extends Action<Map<string, FtpFetchObjectType[]>> {

    topNode: string
    cnt:number = -1  

    getNextNode = (topNode:string)  => sprintf("%s_%04d", topNode, ++this.cnt)

    constructor( _topNode: string = 'Swarm', public inParallel: number = 10 ) {
        super()
        this.topNode = _topNode
        while ( ctrl.graph.hasNode(this.topNode) ) {
            this.topNode = this.getNextNode(_topNode)
        }
        this.cnt = -1 
    }

    async main(): Promise<boolean> {
        ctrl.graph.addNode(this.topNode)
        console.log ( `running ${this.meta.name}`)
        //
        // loop through the list of remote files
        //
        let fileList: Readonly<FtpFetchObjectType[]> = ctrl.getState('FtpList')

        let actionCount = 0       
        let childNode = this.getNextNode(this.topNode)
        fileList.forEach( async ( ftpFetchObject: FtpFetchObjectType, idx ) => {
            let storeName = ftpFetchObject.fileName
            try {
                if ( actionCount % this.inParallel === 0 ) {
                    childNode = this.getNextNode(this.topNode)
                    ctrl.graph.addNode(childNode)
                    ctrl.graph.addDependency(this.topNode, childNode)
                }
                let obj = await new FtpFetch( ftpFetchObject).register(storeName)
                ctrl.graph.addDependency(childNode, storeName)
                actionCount++
            }
            catch (err) {
                throw new CxError( __filename, 'SwarmFtp.getState()', 'FTP-0003',`SwarmFtp.main() failed with: ${err}`, err)
            }
        })
        return Promise.resolve(true)
    }
} 

@action({
    state: {
        FtpFetchObjectType: {},
    }   
})
export class FtpExecute extends Action<Map<string, FtpFetchObjectType[]>> {

    constructor( public topNode: string  ) {
        super()
        /*
        if ( ! ctrl.graph.hasNode( topNode )) {
            throw new CxError( __filename, 'FtpExecute.constructor()', 'FTP-0004',`Top node ${topNode} does not exist`)
        }
        */
    }
    async main() {
        let nodeMem = ""
        try {
            let nodes = ctrl.graph.getIncomingEdges(this.topNode)
            nodes.forEach( async (node: string, idx: number) => {
                console.log ( `running ${this.meta.name}: ${node}`)
                nodeMem = node
                let promiseChain = ctrl.getPromiseChain(node)
                await promiseChain.run()
            })
        }
        catch(err) {
            throw new CxError( __filename, 'FtpExecute.main()', 'FTP-0005',`Promise chain execution for node ${nodeMem} failed.`, err)
        }
    }
}


